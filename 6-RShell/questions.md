1. How does the remote client determine when a command's output is fully received from the server, and what techniques can be used to handle partial reads or ensure complete message transmission?

- The remote client determine when a command's output is fully received from the server by looking for a special EOF character (0x04) that the server sends after all command output. The client receives data in a loop, checking after each recv() call if the last byte received matches this marker. The techniques that can be used to handle partial reads or ensure complete message transmission is to allow client to accumulates the output across multiple recv() calls until the EOF marker is detected. By doing this it ensures the client can properly handle commands that generate large outputs split across multiple TCP packets without relying on connection termination.

2. This week's lecture on TCP explains that it is a reliable stream protocol rather than a message-oriented one. Since TCP does not preserve message boundaries, how should a networked shell protocol define and detect the beginning and end of a command sent over a TCP connection? What challenges arise if this is not handled correctly?

- A networked shell protocol should define and detect the beginning and end of a command sent over a TCP connection by explicitly marking command boundaries using techniques like length prefixing, delimiter characters (such as the EOF character 0x04), or protocol-specific encoding. If this is not handled correctly, a receiving system might incorrectly combine parts of different commands or prematurely process incomplete commands, leading to parsing errors, command injection vulnerabilities, or hung connections waiting for more data that will never arrive.

3. Describe the general differences between stateful and stateless protocols.

- Stateful protocols maintain information about the client-server interaction across multiple requests, requiring servers to store session data between communications. Stateless protocols, conversely, treat each request as independent and self-contained, with no server-side memory of previous interactions. Stateful protocols provide better communication by eliminating redundant information in subsequent requests, but they are hard to impplement and also hard to scale up. Stateless protocols on the other hand are easier to build, more resilient to failures, and easier to scale horizontally. But they may require more bandwidth as each request must contain all necessary context.

4. Our lecture this week stated that UDP is "unreliable". If that is the case, why would we ever use it?

- The reason why we might use UDP, is because it's valuable for applications where speed and low overhead are prioritized over perfect reliability. UDP are used in real-time applications like video streaming, online gaming, and VoIP where some packet loss is acceptable but latency is critical. It's also useful for simple query-response patterns (DNS lookups), broadcast/multicast scenarios, and situations where applications implement their own reliability mechanisms on top of UDP. The protocol's minimal header size and absence of connection establishment make it significantly faster and more efficient than TCP for these use cases.

5. What interface/abstraction is provided by the operating system to enable applications to use network communications?

- The socket API (Application Programming Interface) is the abstraction provided by operating systems to enable network communications. Sockets serve as endpoints for sending and receiving data across a network, offering a file descriptor-like interface that allows applications to use familiar I/O operations. The socket interface provides functions for creating connections (socket(), bind(), listen(), connect()), transferring data (send(), recv(), read(), write()), and managing connections (close(), setsockopt()). This abstraction helps applications from the complexities of network protocols and hardware,which helps developers to build networked applications without having to know how the underlying network implementation works.
